import math

from src.NTRUCrypt.EncryptionParameters import Parameters
from src.Utils.Arithmetic import i2osp

"""
These classes will be used to implement a "index generation function", while keeping track
of the current internal state for the next generation

[1]: IEEE Std 1363.1 - IEEE Standard Specification for Public Key Cryptographic Techniques Based on Hard Problems over Lattices (http://ieeexplore.ieee.org/document/4800404/)
"""


class State:
    """
    This class represents the state of the index generating function.
    The internals of the state are specified in section 8.4.2.1 in [1]
    """

    def __init__(self, Z: str, remLen: int, buf: str, counter: int, N: int, c: int):
        self.Z = Z
        self.remLen = remLen
        self.buf = buf
        self.counter = counter
        self.N = N
        self.c = c

class IGFError(Exception):
    """
    This class will be used to represent errors that have to do with
    the IGF object specified below
    """
    pass

class IGF:

    def __init__(self, seed: bytearray, hashSeed: bool):
        """
        This constructor will return a Index Generator with an initial state specified by the
        parameters. This algorithm is specified in part a of the algorithm in section 8.4.2.1
        :param seed: octet string seed
        :param N: modulus, an integer
        :param hashSeed: boolean taking the values "yes/true" or "no/false"
        :param c: index generation constant, an integer
        :param minCallsR: minimum number of calls, an integer
        """
        if not Parameters.initialized:
            raise IGFError("Initialize the parameters before creating an IGF!")
        if Parameters.minCallsR > 2**32:                                # 2
            raise IGFError("minCallsR argument is bigger than 2^32")    # 2
        if isinstance(seed, str):
            seed = bytearray(seed.encode('utf-8'))

        if hashSeed:                                                    # 3
            Z = IGF._hashString_(seed)                                      # I
            zLen = len(Z)                                                   # I
        else:
            Z = seed                                                        # II
            zLen = len(Z)                                                   # II

        remLen = 0                                                      # 4
        buf = ""                                                        # 5
        counter = 0                                                     # 6
        while counter < Parameters.minCallsR:                           # 8
            C = i2osp(counter, 4)                                           # I
            H = IGF._hashString_(Z + C)                                     # II
            for i in range(len(H)):                                         # III
                buf += "{0:08b}".format(H[i])                               # III
            counter += 1                                                    # IV
        remLen = Parameters.minCallsR * 8 * IGF.hLen()                  # 9
        self.state = State(Z, remLen, buf, counter, Parameters.N, Parameters.c)

    def generateIndex(self):
        """
        This function will generate an index from the previous state.
        This algorithm is specified in section 8.4.2.1 starting at part (c) of [1]
        :return: index i generated by the function
        """
        if not hasattr(self, 'state'):          # check if the IGF object has a state
            raise IGFError("The IGF should have a state before generating an index")

        state = self.state
        b = True
        i = 0

        while b:                                                        # g
            if state.remLen < state.c:                                  # c
                M = state.buf[-state.remLen:]                               # 1
                tmpLen = state.c - state.remLen                             # 2
                cThreshold = state.counter + math.ceil(tmpLen / IGF.hLen()) # 3
                while state.counter < cThreshold:                           # 4
                    C = i2osp(state.counter, 4)                                 # I
                    H = IGF._hashString_(state.Z + C)                           # II
                    for i in range(len(H)):                                     # III
                        M += "{0:08b}".format(H[i])                             # III
                    state.counter += 1                                          # IV
                    state.remLen *= 8                                           # IV
                    if state.counter > 2**32:                                   # V
                        raise IGFError("counter has become bigger than 2^32 !") # V
                state.buf = M                                               # 5
            b = state.buf[-state.c:]                                     # e
            state.buf = state.buf[:-state.c]                             # e
            i = int(b, base=2)                                          # f
            b = False                                                   # g
            if i >= (2**state.c - (2**state.c % state.N)):              # g
                b = True                                                # g
        self.state = state                                              # h
        return i % state.N                                              # i

    @staticmethod
    def hLen():
        return Parameters.igfhash().digest_size

    @staticmethod
    def _hashString_(value: bytearray) -> bytearray:
        """
        This function will hash the string value and return the hex output
        :param value: string to hash
        :return: hex output of the string hash
        """
        m = Parameters.igfhash()            # get a hash instance specified by EncryptionParameters.py
        m.update(value)                     # add the string to the buffer of the hash, this has to be a bytestring, not a normal string
        return m.digest()                   # return the hex output of the hash function


